#!/usr/bin/env node
/*!
 * @file
 * OS.js - JavaScript Operating System - create-project
 *
 * Create a new package from a metadata file. Also handles parsing
 * of Glade schemes.
 *
 * Copyright (c) 2011-2012, Anders Evenrud <andersevenrud@gmail.com>
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @author Anders Evenrud <andersevenrud@gmail.com>
 * @licence Simplified BSD License
 * @created 2012-01-04
 */

///////////////////////////////////////////////////////////////////////////////
// IMPORTS
///////////////////////////////////////////////////////////////////////////////

var _config     = require('../config'),
    _packages   = require(_config.PATH_SRC + '/packages.js');

var _path     = require('path'),
    _fs       = require('fs'),
    _cp       = require('child_process');

var swig      = require('swig');

var tpl_node  = _config.PATH_TEMPLATES + '/package.node.js';
var tpl_js    = _config.PATH_TEMPLATES + '/package.main.js';
var tpl_css   = _config.PATH_TEMPLATES + '/package.main.css';

///////////////////////////////////////////////////////////////////////////////
// SETTINGS
///////////////////////////////////////////////////////////////////////////////

var language = _config.DEFAULT_LANGUAGE || 'en_US';

var opts = {
  'package'           : 'FooBar',
  'default_language'  : language,
  'icon'              : 'emblems/emblem-unreadable.png',
  'type'              : 'Application',
  'linguas'           : JSON.stringify({}),

  // Application Specific
  'mimes'             : JSON.stringify([]),
  'compability'       : JSON.stringify([]),
  'windows'           : [],
  'glade_window'      : '',
  'code_prepend'      : '',
  'code_append'       : ''
};

///////////////////////////////////////////////////////////////////////////////
// INIT
///////////////////////////////////////////////////////////////////////////////

swig.init({
  allowErrors : false,
  autoescape  : false,
  cache       : false,
  encoding    : 'utf8',
  filters     : {},
  root        : _config.PATH_TEMPLATES,
  tags        : {},
  extensions  : {},
  tzOffset    : 0
});

if ( process.argv.length < 3 ) {
  console.error('Usage: ./bin/create-project <metadata.json>');
  process.exit(0);
}

///////////////////////////////////////////////////////////////////////////////
// MAIN
///////////////////////////////////////////////////////////////////////////////

var metafile = process.argv[2]
var outdir   = _path.dirname(metafile);

try {
  var data = _fs.readFileSync(metafile, 'utf-8').toString();
  var info = _packages._parseMetadata(JSON.parse(data), language, true);

  var linguas = {};

  var i;
  for ( i in info.titles ) {
    if ( info.titles.hasOwnProperty(i) ) {
      if ( !linguas.title ) {
        linguas.title = {};
      }
      linguas.title[i] = info.titles[i];
    }
  }

  for ( i in info.descriptions ) {
    if ( info.descriptions.hasOwnProperty(i) ) {
      if ( !linguas.description ) {
        linguas.description = {};
      }
      linguas.description[i] = info.descriptions[i];
    }
  }

  opts['package']       = info.packagename;
  opts['icon']          = info.icon;
  opts['mimes']         = JSON.stringify(info.mimes || []);
  opts['compability']   = JSON.stringify(info.compability || []);
  opts['type']          = info.type;

  if ( opts['type'] == 'Application' && info['schema'] ) {
    console.log('>>>', 'Parsing Glade XML', info['schema']);
    try {
      var schemapath = _path.join(outdir, info['schema']);
      var xmldoc     = _fs.readFileSync(schemapath).toString();

      console.log('<<<', schemapath);
      var parsed = require(_config.PATH_SRC + '/glade.js').parser(xmldoc);
      var windows = [];
      var w, a, s, ss, piter, witer, siter, val, sname, handler, tpl;

      for ( w in parsed ) {
        if ( parsed.hasOwnProperty(w) ) {
          piter = parsed[w];
          witer = {
            name        : w,
            html        : piter.html.replace(/^(.*)$/m, '').replace(/\r?\n/g, '').replace(/\s+/g, ' '),
            is_dialog   : piter.type == "dialog",
            code_init   : '',
            signals     : []
          };

          linguas[w + '_title'] = {};

          for ( s in piter.signals ) {
            if ( piter.signals.hasOwnProperty(s) ) {
              siter = piter.signals[s];
              for ( ss in siter ) {
                if ( siter.hasOwnProperty(ss) ) {
                  tpl = null;
                  handler = siter[ss].match(/^Event/) ? siter[ss] : ('Event' + siter[ss]);

                  switch ( handler ) {
                    case 'EventMenuOpen' :
                      tpl = 'DefaultFileOpen';
                    break;
                    case 'EventMenuSave' :
                      tpl = 'DefaultFileSave';
                    break;
                    case 'EventMenuSaveAs' :
                      tpl = 'DefaultFileSaveAs';
                    break;
                    case 'EventMenuClose' :
                    case 'EventMenuQuit' :
                    case 'EventQuit' :
                    case 'EventClose' :
                      tpl = 'DefaultClose';
                    break;
                    case 'EventMenuTextCopy' :
                      tpl = 'DefaultClipboardCopy';
                    break;
                    case 'EventMenuTextPaste' :
                      tpl = 'DefaultClipboardPaste';
                    break;
                    case 'EventMenuTextCut' :
                      tpl = 'DefaultClipboardCut';
                    break;
                    case 'EventMenuTextSelectAll' :
                      tpl = 'DefaultClipboardSelectAll';
                    break;
                    case 'EventMenuTextDelete' :
                      tpl = 'DefaultClipboardDelete';
                    break;
                    default :
                      tpl = 'NotImplemented';
                    break;
                  }

                  witer.signals.push({
                    id      : s,
                    signal  : ss,
                    template: tpl,
                    handler : handler
                  });
                }
              }
            }
          }

          for ( a in piter.attributes ) {
            if ( piter.attributes.hasOwnProperty(a) ) {
              val = piter.attributes[a] || null;
              if ( (val !== null) && (typeof val !== 'boolean') && (typeof val !== 'number') ) {
                val = "'" + val + "'";
              }

              if ( a == 'title' ) {
                linguas[w + '_title'][language] = (val || piter.attributes[a]);
                val = 'LABELS[\'' + w + '_title\'] || LABELS[\'title\']';
              } else if ( a == 'icon' ) {
                if ( val === null ) {
                  val = opts['icon'] ? '\'' + opts['icon'] + '\'' : '\'emblems/emblem-unreadable.png\'';
                }
              }

              witer.code_init += '        this._' + a + ' = ' + val + ";\n";
            }
          }

          if ( !opts['glade_window'] || ( w == 'window_main') ) {
            console.info('!', w, 'selected as main window');
            opts['code_prepend'] = 'var root_window = new Window_' + w + '(this);';
            opts['glade_window'] = 'root_window';
            opts['code_append']  = 'root_window.show();';
          }

          windows.push(witer);
        }
      }

      opts.windows = windows;
    } catch ( err ) {
      console.error('Failed to glade document', schemapath, err);
    }
  }

  opts['linguas']       = JSON.stringify(linguas || {}, null, '    ');

  var out_node = _path.join(outdir, opts['package'] + '.node.js');
  try {
    console.log('>>>', 'Generating node script');
    var res_node  = swig.compileFile(tpl_node).render(opts);
    _fs.writeFileSync(out_node, res_node);
    console.log('<', out_node);
  } catch ( err ) {
    console.error('... failed:', err);
    process.exit(1);
  }

  var out_js   = _path.join(outdir, 'main.js');
  try {
    console.log('>>>', 'Generating main javascript');
    var res_js    = swig.compileFile(tpl_js).render(opts);
    _fs.writeFileSync(out_js, res_js);
    console.log('<', out_js);
  } catch ( err ) {
    console.error('... failed:', err);
    process.exit(1);
  }

  var out_css  = _path.join(outdir, 'main.css');
  try {
    console.log('>>>', 'Generating main stylesheet');
    var res_css   = swig.compileFile(tpl_css).render(opts);
    _fs.writeFileSync(out_css, res_css);
    console.log('<', out_css);
  } catch ( err ) {
    console.error('... failed:', err);
    process.exit(1);
  }
} catch ( err ) {
  console.error('Failed to read metadata:', err);
  process.exit(1);
}

console.info('Done!');
process.exit(0);
